---
title: "Relatório do Projeto de Disciplina"
subtitle: "Análise Exploratória de Dados"
author: "Eraldo N. Ferreira Pinto Júnior"
date: "`r format(Sys.time(), '%d %B, %Y')`"
header-includes:
- \usepackage{pdflscape}
- \newcommand{\blandscape}{\begin{landscape}}
- \newcommand{\elandscape}{\end{landscape}}
- \usepackage[utf8]{inputenc}
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = 'D:/Study/Infnet/DataScience/ExploratoryDataAnalysis/Workspace/GitHub/ExploratoryDataAnalysis')
#                        'C:/Users/eraldojr/Documents/Teste/ExploratoryDataAnalysis/ExploratoryDataAnalysis')
knitr::opts_chunk$set(echo = TRUE, 
                      message = TRUE, 
                      warning = TRUE, 
                      fig.path = 'Images/',
                      fig.align = 'center', 
                      fig.retina = 2,
                      fig.dim = c(7, 5), 
                      dev = "png",
                      dpi = if (knitr::is_latex_output()) 72 else 300,
                      out.width = "100%",
                      kable.table.width = 1.0
                      )
```

\newpage

# Sumário

1. [**Introdução**](#introdução)

2. [**Preparando o Ambiente**](#preparandooambiente)
      + [**Pacotes**](#pacotes)
      + [**Funções Criadas**](#funcoes)

3. [**Dos Dados**](#dosdados)
      + [**Contexto**](#contexto)
      + [**Fonte dos dados**](#fontededados)

4. [**Realizando o carregamento dos dados**](#carregandoosdados)

5. [**Visão Inicial dos Dados**](#visaodosdados)

6. [**Analisando os tipos de cada variável nas bases**](#analisandobases)
      + [**Base de Dados Combustíveis - Visão da pesquisa nacional**](#basecobustiveis)
      + [**Base de Dados Câmbio**](#basecambio)
      + [**Base de Dados Brent**](#basebrent)
      + [**Base de Dados PPI**](#baseppi)

7. [**Tratamento das Datas**](#tratandodatas)

8. [**Análise de frequências de variáveis qualitativas**](#analisefreqvarquali)

9. [**Gerando dados calculados**](#calculodedados)

10. [**Merge das bases de dados**](#merge)

11. [**Calculando as estatísticas descritiva dos dados**](#estatisticadescritiva)

12. [**Análise descritiva e de histogramas das variáveis contínuas**](#analisedescritivaehistograma)
      + [**Análise descritiva das variáveis contínuas**](#analisedescritivavarcontinua)
      + [**Histogramas das variáveis contínuas**](#histogramadasvarcontinuas)

13. [**Calculando a dispersão e as correlações**](#calcDispCorre)
      + [**Para a Gasolina**](#paragasolina)
      + [**Para a Diesel**](#paradiesel)
      + [**Para a Diesel S10**](#paradieselS10)
      + [**Para GLP 13Kg**](#paraGLP13)

14. [**Analisando a normalidade dos dados**](#analisandonormaldados)

15. [**Manipulando base de dados com dados faltantes e outliers**](#manipulandomissingeout)
	   + [**Índice de completude**](#indicedecompletude)
      + [**Base de Dados Combustíveis - Visão de missing nacional**](#basecobustiveismissingnacional)
      + [**Base de Dados Combustíveis - Visão de missing estado RJ**](#basecobustiveismissingrj)
      + [**Realizando teste de Little para checar se os dados faltantes são completamente aleatórios**](#testelittle)
      + [**Realizando a imputação de dados**](#imputandodados)

\newpage

# Introdução{#introdução}

Para uma melhor organização deste projeto, foram criadas pastas com propósitos específicos para armazenamento dos arquivos.

A estrutura é dividida da seguinte forma:

-   / - Pasta raiz do projeto:
    -   Dataset - Pasta com os arquivos de extensão CSV.
        -   Brent
        -   Cambio
        -   Combustivel
        -   PPI
    -   Image - Pasta com os arquivo de extensão PNG.
    -   App

# Preparando o Ambiente{#preparandooambiente}

## Pacotes{#pacotes}

Durante a análise foi verificado a necessidade de utilização de alguns pacotes. A lista de pacotes utilizados encontra-se abaixo:

```{r Lista de pacotes, echo=TRUE}
# Lista com todos os pacotes
package <- c("tidyverse", "ggplot2", "summarytools", "data.table", "knitr", "dlookr", "ggpubr", "naniar", "corrplot", "mice", "purrr", "simputation")
```

Com a lista de pacotes mapeados, a próxima etapa tem como foco verificar se todos os pacotes necessários para a análise se encontram instalados. Caso não estejam instalados, o processo de instalação será automático.

Para verificação dos pacotes instalados, a variável *is_installed* receberá o resultado *TRUE* para os pacotes instalados da lista *package* ou *FALSE* para os pacotes não instalados da lista *package*.

```{r Instalando pacotes, echo=TRUE}
# Veritifica se o Pacote está instalado e o instala se for necessário.
is_installed <- package %in% rownames(installed.packages())

if(any(is_installed == FALSE)){
  install.packages(package[!is_installed])
}
```

Com os pacotes instalados, agora é necessário o carregamento deles, para que assim possamos iniciar as tratativas necessárias com os dados da análise.

```{r Carga dos pacotes, echo=TRUE}
# Carregando os Pacotes
invisible(lapply(package, library, character.only = TRUE))
```

Pacotes carregados. Agora vamos remover as variáveis desnecessárias para as próximas etapas.

```{r Removendo variáveis desnecessárias, echo=TRUE}
# Removendo variáveis desnecessárias
rm(list=ls())
```

## Funções Criadas{#funcoes}

Durante a elaboração da análise foi identificado a necessidade de realizar o tratamento das datas, uniformizando-as a partir das diferentes fontes de dados. Foram criadas funções para este tratamento.

A função *transform_date_one* transforma no formato AAAA-mm-dd todos os valores com o formato 12.10.2023 ou 12/10/2023.

A função *transform_date_two* transforma no formato AAAA-mm-dd todos os valores com o formato 12102023.

A função *transform_date_three* transforma no formato AAAA-mm-dd todos os valores com o formato Apr 2023.

Foi criada uma função específica que retornará a data formatada com padrão único, chamada *format_data*. Esta função será utilizada por todas as outras funções *transform_date\_*.

```{r Funções para transformação das dadas, echo=TRUE}
transform_date_one <- function(data){
  partes_da_data <- strsplit(data, "[/.]")
  ano <- as.numeric(sapply(partes_da_data, `[`,3))
  mes <- as.numeric(sapply(partes_da_data, `[`,2))

  data_formatada <- format_data(ano, mes)

  return(data_formatada)
}

transform_date_two <- function(data){
  ano <- as.numeric(substr(data, nchar(data) - 3, nchar(data)))
  mes <- as.numeric(substr(data, nchar(data) - 5, nchar(data) - 4))

  data_formatada <- format_data(ano, mes)

  return(data_formatada)
}

transform_date_three <- function(data){
  ano <- as.numeric(substr(data, nchar(data) - 3, nchar(data)))
  mes_abreviado <- substr(data, nchar(data) - 7, nchar(data) - 5)
  mes <- as.integer(match(mes_abreviado, month.abb))
  
  data_formatada <- format_data(ano, mes)

  return(data_formatada)
}

format_data <- function(ano_data, mes_data){
  data_formatada <- as.Date(sprintf("%04d-%02d-01", ano_data, mes_data))
  return(data_formatada)
}
```

Dando continuidade a necessidade de funções específicas, alguns dados foram disponibilizados pelas suas fontes em arquivos distintos. Para uma carga de dados mais eficiente foram criadas funções que possibilitarão uma agilidade neste processo.

```{r Extrator de dados para vários arquivos, echo=TRUE}
extractor_csv2 = function(dados){
  readr::read_csv2(dados, locale = locale(encoding = 'UTF-8'), show_col_types = FALSE)
}

extractor_csv = function(dados){
  read.csv(dados, header = FALSE, sep = ";", dec = ",")
}

```

Abaixo é descrita as funções geradoras de binwidths.

```{r Geradoras de binwidths FD e S, echo = TRUE}

fd <- function(x) {
  n <-length(x)
  return((2*IQR(x))/n^(1/3))
}


sr <- function(x) {
  n <-length(x)
  return((3.49*sd(x))/n^(1/3))
}

```

***

# Dos Dados{#dosdados}

## Contexto{#contexto}

O valor de venda dos derivados de petróleo aos consumidores brasileiros é sempre um assunto polêmico. Há muitas variáveis que influenciam na flutuação do valor de venda. Para o consumidor final o que importa é o quanto estas flutuações impactam no orçamento mensal da família.

Os meios de comunicação frequentemente noticiam o aumento ou a redução dos derivados do petróleo diante da flutuação de algumas variáveis, como por exemplo o brent e o câmbio.

A flutuação destas variáveis e de outras são oriundas de acontecimentos mundiais. Os grandes canais de comunicação noticiam periodicamente estes eventos.

-   O ["Petróleo sobe mais de 3% em meio a tensões no Oriente Médio"](https://www.cnnbrasil.com.br/economia/mercado/petroleo-sobe-mais-de-3-em-meio-a-tensoes-no-oriente-medio/) (CNN-Brasil, 2024).
-   A ["Guerra e petróleo: veja reações mais drásticas da commodity a grandes conflitos"](https://www.cnnbrasil.com.br/economia/guerra-e-petroleo-veja-reacoes-mais-drasticas-da-commodity-a-grandes-conflitos/) (CNN-Brasil, 2023).
-   A ["Gerra no Oriente Médio pode aumentar preço do diesel, diz Petrobras"](https://agenciabrasil.ebc.com.br/economia/noticia/2023-10/guerra-no-oriente-medio-pode-aumentar-preco-do-diesel-diz-petrobras) (AgênciaBrasil-EBC, 2023).

Além das variáveis, uma sigla foi introduzida na vida dos brasileiros diante a mudança da política de preço praticada pela petrolífera brasileira (Petrobras). Esta sigla é conhecida como o Preço de Paridade de Importação - PPI.

Um breve histórico da adoção do PPI pela Petrobras e seus desdobramentos políticos pode ser lido na matéria ["Gasolina cara, lucro recorde: como foi o PPI, antiga política da Petrobras"](https://economia.uol.com.br/noticias/redacao/2023/05/16/como-funcionava-o-ppi-antiga-politica-de-precos-da-petrobras.htm) (Economia UOL, 2023)

O fim da adoção do PPI pela Petrobras em 16 de maio de 2023 repercutiu nacionalmente.

-   A ["Petrobras anuncia fim da paridade internacional de preços do petróleo"](https://www.cnnbrasil.com.br/economia/petrobras-anuncia-fim-da-paridade-internacional-de-precos-do-petroleo/#:~:text=Petrobras%20anuncia%20fim%20da%20paridade%20internacional%20de%20pre%C3%A7os%20do%20petr%C3%B3leo,-Paridade%20de%20importa%C3%A7%C3%A3o&text=A%20Petrobras%20anunciou%20nesta%20ter%C3%A7a,economia%20da%20CNN%2C%20Raquel%20Landim.) (CNN Brasil, 2023). ["Para Ineep, fim do PPI na Petrobras trouxe maior estabilidade de preço dos combustíveis"](https://www.infomoney.com.br/mercados/para-ineep-fim-do-ppi-na-petrobras-trouxe-maior-estabilidade-de-preco-dos-combustiveis/) (InfoMoney, 2024).
-   A ["Gasolina da Petrobras está 17% mais barata que preço internacional"](https://www.metropoles.com/negocios/gasolina-da-petrobras-esta-17-mais-barata-que-preco-internacional) (Metrópoles, 2024).

Em resumo, o experimento visa compreender o preço de venda de combustíveis entre o período de adoção da política de preço da Petrobras e o fim da adoção desta política.

O espaço amostral para o experimento envolve os combustíveis Diesel, Diesel S10 e Gasolina pesquisados através de pesquisa nos postos de combustíveis selecionados pela ANP.

O período de coleta dos dados ocorrerá entre janeiro de 2020 até março de 2024.

## Fonte dos dados{#fontededados}

Um fator crucial para qualquer análise é a busca de fontes de dados abertos confiáveis. Portanto, buscou-se através de sites oficiais de governo e instituições renomadas os dados necessários para a respectiva análise.

O primeiro dado a ser obtido foi a ["Série Histórica de Preços de Combustíveis e de GLP"](https://www.gov.br/anp/pt-br/centrais-de-conteudo/dados-abertos/serie-historica-de-precos-de-combustiveis) (Dados Abertos-ANP, 2024). Esta fonte de dados possui os dados das pesquisas realizadas até março de 2024. Os dados utilizandos para esta análise foram os dados oriundos das pesquisas realizadas até março de 2024.

Ainda no site da ANP, foi utilizado os ["Preços de paridade de importação"](https://www.gov.br/anp/pt-br/assuntos/precos-e-defesa-da-concorrencia/precos/precos-de-paridade-de-importacao) (PPI-ANP, 2024).

O Brent foi obtido através da *U.S. Energy information Administration - EIA*. Os dados obtidos fazem parte da visão histórica dos dados em [*PETROLEUM & OTHER LIQUIDS*](https://www.eia.gov/dnav/pet/hist/rbrteM.htm) (EIA, 2024).

A série histórica da taxa cambial foi obtida através do site do Banco Central do Brasil, em sua área ["Cotações e boletins"](https://www.bcb.gov.br/estabilidadefinanceira/historicocotacoes) (BCB, 2024).

***

# Realizando a carga dos dados{#carregandoosdados}

Neste momento será realizado o carregamento dos dados obtidos através das fontes de dados supracitadas. Os dados foram armazenados nas subpastas da pasta Dataset.

Para realização desta etapa, duas estratégias foram adotadas.

A primeira estratégia, de forma recursiva, se utilizou o *list.files* para localizar todos os arquivos a partir de um *pattern* (padrão) no nome dos arquivos. Uma variável com a lista contendo o nome do arquivo e o caminho foi criada para armazená-las. Posteriormente foi utilizada a função map_dfr para aplicar cada elemento (arquivos) na função criada para extração dos dados. Esta estratégia envolve a carga de dados histórica dos combustíveis, glp e taxa de câmbio que são constituídas de vários arquivos.

```{r Carga de dados dos combustíveis, echo=TRUE}
arquivos <- list.files(pattern = "^ca-", recursive = TRUE)
origin_combustiveis_agg <- map_dfr(arquivos, extractor_csv2)
message("Dados carregados dos arquivos CSV.")

rm(arquivos)
```

Iniciando a carga dos dados do câmbio.

```{r Carga de dados do câmbio, echo = TRUE}
arquivos <- list.files(pattern = "^CotacoesMoedasPeriodo", recursive = TRUE)
origin_cambio <- map_dfr(arquivos, extractor_csv)

rm(arquivos)
```

A segunda estratégia, foi mais simples, pois se refere a extração de um único arquivo com todos os dados históricos do Brent.

```{r Carga de dados do brent, echo = TRUE}
origin_brent <- read.table("Dataset/Brent/Europe_Brent_Spot_Price_FOB.csv", sep=",", 
                    header = TRUE)
```

A segunda estratégia também foi adotada para a extração de um único arquivo com todos os dados históricos do PPI.

**Atenção:** Os dados do PPI foram disponibilizados em vários sheets em uma única planilha do Excel, com extensão XLSX. Foi necessário tratar os dados diretamente no Excel, possibilitando assim um carregamento mais célere.

```{r Carga de dados do PPI, echo = TRUE}
origin_ppi_agg <- read.table("Dataset/PPI/ppi.csv", sep=";", dec = ",", 
                  header = TRUE)
```

***

# Visão Inicial dos Dados{#visaodosdados}

Após a importação das bases de dados, vamos apresentar as primeiras observações para conhecimento das variáveis.

```{r Visão geral das variáveis, echo = TRUE}
head(origin_combustiveis_agg)
head(origin_cambio)
head(origin_brent)
head(origin_ppi_agg)

#knitr::kable(origin_combustiveis_agg, 
#             format="latex",
#             caption = "Base de dados da pesquisa de combustíveis.",
#             align = "c",
#             booktabs = TRUE,
#             longtable = TRUE,
#             linesep = ""
#)
```

***

# Analisando os tipos das variáveis nas bases{#analisandobases}

Após a carga dos dados, foi necessário identificar o tipo de cada variável nas bases. Utilizar-se-á a função diagnose do pacote dlookr que reportará o tipo em todas as bases.

## Base de Dados Combustíveis{#basecobustiveis}

```{r Identificando os tipos de variáveis da base de pesquisa combustíveis, echo = TRUE}
origin_combustiveis_agg %>% dlookr::diagnose()
origin_combustiveis_agg %>% dplyr::select(Produto) %>% base::unique()

origin_combustiveis_agg %>%
  dplyr::group_by(Produto) %>%
  dplyr::mutate(n_linhas = 1) %>%
  dplyr::summarise(n_linhas = sum(n_linhas))
```

As variáveis deste contjunto de dados pode ser classificadas conforme a tabela abaixo.

\begin{center}
Table 1: Classificação das variáveis da base de dados combustíveis.
\end{center

| Variável          | Classificação         |
|-------------------|-----------------------|
| Regiao - Sigla    | Qualitativa nominal   |
| Estado - Sigla    | Qualitativa nominal   |
| Municipio         | Qualitativa nominal   |
| Revenda           | Qualitativa nominal   |
| CNPJ da Revenda   | Qualitativa nominal   |
| Nome da Rua       | Qualitativa nominal   |
| Numero Rua        | Qualitativa nominal   |
| Complemento       | Qualitativa nominal   |
| Bairro            | Qualitativa nominal   |
| Cep               | Qualitativa nominal   |
| Produto           | Qualitativa nominal   |
| Data da Coleta    | Qualitativa nominal   |
| Valor de Venda    | Quantitativa contínua |
| Valor de Compra   | Quantitativa contínua |
| Unidade de Medida | Qualitativa nominal   |
| Bandeira          | Qualitativa nominal   |

É possível identificar a existência na base de 16 variáveis. Um total de 14 variáveis são qualitativas, sendo estas nominais. Sobre as variáveis quantitativas, temos Valor de Venda e Valor de Compra, ambas variáveis contínuas.

Observa-se que as variáveis Numero da rua, Complemento, Bairro e Valor de Venda possuem missing.

No Brasil, a pesquisa foi realizada:

-   Em 5 regiões.

-   Em 27 estados.

-   Em 469 municípios.

-   Em 19.961 revendas por CNPJ.

-   Considerando 6 produtos comercializados.

    -   GASOLINA
    -   ETANOL
    -   DIESEL S10
    -   GNV
    -   DIESEL
    -   GASOLINA ADITIVADA

-   E o missing do Valor de Compra foi de 3.420.835, o qual representa 95,64% da base de dados.

-   Em 80 bandeiras diferentes.

-   As variáveis de interesse nesta base de dados são:

    -   Regiao - Sigla
    -   Estado - Sigla
    -   Municipio
    -   CNPJ da Revenda
    -   Produto
    -   Data da Coleta
    -   Valor de Venda
    -   Valor de Compra
    -   Unidade de Medida
    -   Bandeira

## Base de Dados Câmbio{#basecambio}

Dando continuidade, será realizada a análise da próxima base de dados, taxa de câmbio.

```{r Conhecendo as variáveis da base de dados Câmbio, echo = TRUE}
str(origin_cambio)
origin_cambio %>% dlookr::diagnose()
```

Ao inspecionar a base de dados, é possível identificar na base a existência de 8 variáveis. Neste primeiro momento não foi possível identificar claramente o propósito das variáveis. Para isso, foi utilizado a função head para leitura dos primeiros dados da base.

É possível observar que a variável V1 é do tipo integer, contudo, ela expressa a data de cotação do câmbio, portanto, é uma variável qualitativa nominal. As variáveis V5 e V6 expressão, respectivamente, cotação de compra e venda na moeda real. Portanto, são quantitativas e ambas são contínuas. A variável V2, V3 e V4, através da informação contida na descrição da base, são: V2 - Código da Moeda, V3 - Tipo da Moeda e V4 - Símbolo da Moeda. Ambas são qualitativas nominais. As variáveis V7 e V8 não possuem descrição na base.

Para o objetivo da análise, as variáveis selecionadas serão V1 e V5.

## Base de Dados Brent{#basebrent}

A análise de variável desta base de dados foi mais simples. A base é composta por duas variáveis. A data é uma variável qualitativa nominal e a variável Preco USD/Barril é quantitativa contínua.

```{r Conhecendo as variáveis da base de dados Brent, echo = TRUE}
str(origin_brent)
origin_brent %>% dlookr::diagnose()
```

## Base de Dados PPI{#baseppi}

Considerando que esta base de dados passou por um tratamento prévio e externo, as variáveis existentes são os valores do PPI por portos e pontos de entrega. A data é uma variável qualitativa nominal e as variáveis que representam os portos e os pontos de entrega são quantitativas contínuas.

```{r Conhecendo as variáveis da base de dados PPI, echo = TRUE}
str(origin_ppi_agg)
origin_ppi_agg %>% dlookr::diagnose()
```

Para a respectiva análise utilizar-se-á as variáveis Data e PPI por produto.

***

# Normatizando o nome e escolhendo as variáveis{#normalizandovariaveis}

Normatizando as variáveis da base de combustíveis.

```{r Normatizando o nome da base de dados combutíveis, echo=TRUE}
colnames(origin_combustiveis_agg) <- c("Regiao",
                                       "UF",
                                       "Municipio",
                                       "Revenda",
                                       "CNPJ_Revenda",
                                       "Rua",
                                       "Numero_rua",
                                       "Complemento",
                                       "Bairro",
                                       "CEP",
                                       "Produto",
                                       "Data",
                                       "Valor_de_Venda",
                                       "Valor_de_Compra",
                                       "Unidade_de_Medida",
                                       "Bandeira"
)
```

Selecionando um conjunto de variáveis da base combustíveis e os produtos.

```{r Variáveis da base combustível selecionadas para a análise, echo=TRUE}
sample_combustiveis_agg <- origin_combustiveis_agg[,c(1,2,3,5,11,12,16,13,14)]

sample_combustiveis_agg <- sample_combustiveis_agg %>% 
   dplyr::filter(Produto == "GASOLINA" | Produto == "DIESEL S10" | Produto == "DIESEL")
```

Normatizando a base de dados brent.

```{r Normatizando o nome e escolhendo as variáveis da base de dados brent, echo=TRUE}
colnames(origin_brent) <- c("Data", "Brent_USD_Barril")
```

Selecionando um conjunto de variáveis e normatizando a base de dados cambio.

```{r Normatizando o nome e escolhendo as variáveis da base de dados cambio, echo=TRUE}
sample_cambio <- origin_cambio[, c(1, 5)]
colnames(sample_cambio) <- c("Data", "Taxa_Cambio")
```

***

# Tratamento e padronizando as Datas{#tratandodatas}

As quatro bases de dados dispostas nesta análise (combustiveis, cambio, brent e ppi) possuem datas com formatos e características diferentes.

A uniformização das datas possibilitará mesclar estes dados em uma única base de dados.

Para esta uniformização, as funções de transformação das datas serão chamadas, passando como parâmetro o campo data das bases de dados.

```{r Padronizando a formatação das datas, echo=TRUE}
origin_combustiveis_agg$Data <- transform_date_one(origin_combustiveis_agg$Data)
sample_combustiveis_agg$Data <- transform_date_one(sample_combustiveis_agg$Data)
origin_brent$Data <- transform_date_three(origin_brent$Data)
sample_cambio$Data <- transform_date_two(sample_cambio$Data)
origin_ppi_agg$Data <- transform_date_one(origin_ppi_agg$Data)

rm(origin_cambio)
```

***

# Gerando dados calculados{#calculodedados}

Para a realização da próxima etapa da análise, a qual envolve o *merge* entre as bases de dados até aqui apresentada, será necessário realizar filtros e cálculos.

A variável taxa de câmbio da base de dados cambio é composta por valores cotados diariamente.

Para uma uniformização mensal dos dados, foi realizado cálculos estatísticos do câmbio praticado mensalmente a partir do valor diário.

```{r Cálculo estatísico do câmbio mensal, echo=TRUE}
calc_cambio <- sample_cambio %>% 
   dplyr::group_by(Data) %>% 
   dplyr::summarise(Cambio = mean(Taxa_Cambio),.groups = 'drop')
#   dplyr::summarise(Cambio = mean(Taxa_Cambio), 
#                    Max_Cambio = max(Taxa_Cambio), 
#                    Min_Cambio = min(Taxa_Cambio),
#                    SD_Cambio = sd(Taxa_Cambio),.groups = 'drop')
```

Foi gerada uma nova base de dados, tendo como descrição o termo calc de calculada. Utilizou-se a função group_by() do pacote dplyr para agrupar os dados pela data e posteriormente a função summarise() do pacote dplyr para os cálculos.

A variável PPI da base de dados ppi é fruto da análise semanal. As datas semanais foram tratadas para uniformização mensal dos dados. Foram realizados cálculos estatísticos a partir dos valores semanais para o respectivo cálculo mensal.

```{r Cálculo estatístico do ppi mensal, echo=TRUE}
calc_ppi <- origin_ppi_agg %>% 
   dplyr::group_by(Data, Produto) %>% 
   dplyr::summarise(PPI = mean(PPI), .groups = 'drop')
#   dplyr::summarise(PPI = mean(PPI), 
#                    Max_PPI = max(PPI), 
#                    Min_PPI = min(PPI),
#                    SD_PPI = sd(PPI),.groups = 'drop')
```

Foi gerada uma nova base de dados, tendo como descrição o termo calc de calculada. Utilizou-se a função group_by() do pacote dplyr para agrupar os dados pela data e posteriormente a função summarise() do pacote dplyr para os cálculos.

***

# Merge das bases de dados{#merge}

Após a realização do filtro e os devidos cálculos, realizar-se-á nesta etapa o *merge* das bases de dados.

```{r Merge das bases de dados para criação de uma nova base para análise, echo=TRUE}
sample_combustiveis_agg <- dplyr::bind_rows(base::merge(sample_combustiveis_agg %>% 
                                                           dplyr::filter(Produto == "DIESEL" | Produto == "DIESEL S10"), 
                                                        calc_ppi %>% 
                                                           dplyr::filter(Produto == "Diesel") %>% 
                                                           dplyr::select(Data, PPI),
                                                        by = "Data",
                                                        all = TRUE),
                                            base::merge(sample_combustiveis_agg %>% 
                                                           dplyr::filter(Produto == "GASOLINA"),
                                                        calc_ppi %>% 
                                                           dplyr::filter(Produto == "Gasolina") %>% 
                                                           dplyr::select(Data, PPI),
                                                        by = "Data",
                                                        all = TRUE)
                                            )

sample_combustiveis_agg <- base::merge(sample_combustiveis_agg, 
                                          origin_brent, 
                                          by = "Data", 
                                          all = TRUE)

sample_combustiveis_agg <- base::merge(sample_combustiveis_agg, 
                                          calc_cambio, 
                                          by = "Data", 
                                          all = TRUE)

sample_combustiveis_agg <- sample_combustiveis_agg %>% 
   dplyr::mutate(Brent_Real_Barril = Brent_USD_Barril * Cambio)
```

***

# Análise de frequências de variáveis qualitativas{#analisefreqvarquali}

Na base de dados sample_combustiveis_agg, as variáveis Produto, Região, UF, Município e Revenda são variáveis qualitativas nominais na base. São variáveis interessantes para extração das frequências.

Para esta primeira análise de frequência, analisaremos a variável produto utilizando a função freq() do pacote summarytools.

```{r Frequência variáveis qualitatividas dos produtos no Brasil, echo=TRUE}
origin_combustiveis_agg %>% 
   dplyr::select(Produto) %>% 
   summarytools::freq(., style = 'rmarkdown', order = "freq", plain.ascii = FALSE)

sample_combustiveis_agg %>% 
   dplyr::select(Produto) %>% 
   summarytools::freq(., style = 'rmarkdown', order = "freq", plain.ascii = FALSE)
```

Foi possivel observar que durante o **merge** dos dados foram gerados missing. Vamos agora entender do que trata-se esse missing gerado.

```{r Análise do missing gerado, echo=TRUE}
sample_combustiveis_agg %>% 
   dplyr::select(Data) %>% 
   summarytools::freq(., style = 'rmarkdown', order = "freq", plain.ascii = FALSE)

sample_combustiveis_agg %>% 
   dplyr::filter(Data == "2020-09-01")
```

Foi constatado durante as análises que no mês 09 de 2020 não ocorreu nenhuma pesquisa nos postos de combustíveis. Por este motivo, foi necessário remover o respectivo mês da base sample_combustiveis_agg.

```{r Remover mês de setembro de 2020 da base, echo=TRUE}
sample_combustiveis_agg <- sample_combustiveis_agg %>% dplyr::filter(!Data == "2020-09-01")
```

Durando esta etapa de análise de frequências de variáveis qualitativas, vamos trabalhar para identificar os indivíduos de interesse no experimento.

Para este experimento os indivíduos possíveis mapeados são os postos de combustíveis identificados pela variável Revenda e CNPJ_Revenda, Município, UF e Regiao.

O primeiro indivíduo analisado foram os postos de combustíveis a partir do CNPJ_Revenda. Considerando ao volume de dados, a análise partiu para uma amostra menor que possibilita-se identificar que um determinado posto de combustível de uma cidade aleatório no tempo não foi pesquisado no tempo.

```{r Avaliando a frequência do indivíduo Revenda através do seu CNPJ ao ano, echo=TRUE}
filter_municipio = "CAMPOS DOS GOYTACAZES"
filter_ano = "2020"

sample_combustiveis_agg %>% 
   dplyr::mutate(ano = format(Data, "%Y")) %>% 
   dplyr::filter(ano == filter_ano & Municipio == filter_municipio) %>% 
   dplyr::select(CNPJ_Revenda) %>% 
   summarytools::freq(., style = 'rmarkdown', order = "freq", plain.ascii = FALSE)
```

É possível observar que determinados indivíduos denominados Revendas (postos de combustíveis) não contribuem mensalmente para a pesquisa, ratificando a [metodologia](https://www.gov.br/anp/pt-br/assuntos/precos-e-defesa-da-concorrencia/precos/precos-revenda-e-de-distribuicao-combustiveis/informacoes-levantamento-de-precos-de-combustiveis) de que a pesquisa de preços abrange a seleção das revendas em operação cadastradas na ANP, as quais farão parte da amostra.

Diante deste fato, o próximo passo foi avaliar o indivíduo Município

A mesma estratégia foi utilizada, a partir de uma amostra menor que ratifica-se a hipóteses de que nem todos os municípios são pesquisados todos os meses.

```{r Avaliando a frequência do indivíduo Municipio, echo=TRUE}
filter_uf = "RJ"
filter_ano = "2020"

sample_combustiveis_agg %>% 
   dplyr::mutate(ano = format(Data, "%Y")) %>% 
   dplyr::filter(ano == filter_ano & UF == filter_uf) %>% 
   dplyr::select(Municipio) %>% 
   summarytools::freq(., style = 'rmarkdown', order = "freq", plain.ascii = FALSE)
```
Para apurar os municípios que ratificam a hipótese supra, optou-se por analisar os municípios com menor frequência apresentada.

Considerando o município de Nilópolis que possui a menor amostra, foi possível constatar que ele foi pesquisado todos os meses.

O próximo a ser analisado foi o município de Angra dos Reis. Foi constatado que ele não foi pesquisado no mês 11 de 2020. 

Portanto, esta análise ratifica a hipótese apresentada, portanto, desconsiderando os municípios como indivíduos para este experimento.

```{r Avaliando a frequência do indivíduo Municipio chamado Nilopolis, echo=TRUE}
filter_uf = "RJ"
filter_municipio = "ANGRA DOS REIS"
filter_ano = "2020"

sample_combustiveis_agg %>% 
   dplyr::mutate(mes = format(Data, "%m"), ano = format(Data, "%Y")) %>% 
   dplyr::filter(UF == filter_uf, Municipio == filter_municipio, ano == filter_ano) %>%
   dplyr::group_by(mes) %>% 
   dplyr::mutate(n_linhas = 1) %>% 
   dplyr::summarise(n_linhas = sum(n_linhas))
```

É possível observar que determinados indivíduos denominados Municípios não contribuem mensalmente para a pesquisa.

Diante deste fato, o próximo passo foi avaliar o indivíduo UF. Na etapa de **Analisando os tipos das variáveis nas bases** é possível constatar que são 27 unidades federativas (UF) pesquisadas.

A primeira pergunta a ser respondida é: A base de amostra de nome sample_combustiveis_agg continua com a mesma quantidade da base original de nome origin_combustiveis_agg?

```{r Avaliando a quantidade do indivíduo UF, echo=TRUE}
sample_combustiveis_agg %>% dlookr::diagnose()
```
É possível verificar que sim. O próximo passo é verificar se todos os 27 estados são pesquisados mensalmente.

```{r Avaliando a frequência do indivíduo UF, echo=TRUE}
filter_ano = "2020"

sample_combustiveis_agg %>% 
   dplyr::mutate(mes = format(Data, "%m"), ano = format(Data, "%Y")) %>% 
#   dplyr::filter(ano == filter_ano) %>%
   dplyr::group_by(mes, ano) %>% 
   dplyr::distinct(UF) %>% 
   dplyr::count(UF) %>%
   dplyr::summarise(n_uf = sum(n), .groups = 'drop')
```

É possível observar que todos os indivíduos denominados UF contribuíram mensalmente para a pesquisa. Tal afirmação só é valida porque o Brasil é consituído por 26 estados e o Distrito Federal, contabilizando assim 27 unidades federativas.


A análise a seguir visa apresentar um mapa de calor a partir do valor de venda dos combustíveis no Brasil e posteriormente por município da UF selecionada para análise.

```{r Heatmat entre município e produtos por uf, echo = TRUE}
filter_produto = c("GASOLINA","DIESEL","DIESEL S10")
graph_file <- "Heatmat do Valor de Venda dos combustíveis no Brasil"
extensao_file <- "jpg"

sample_combustiveis_agg %>% 
   dplyr::filter(Produto %in% filter_produto) %>%
   ggplot(aes(x = UF, 
              y = Produto, 
              fill = Valor_de_Venda)) + 
   geom_tile() + 
   labs(x = "UF", 
        y = "Produto", 
        title = graph_file, 
        subtitle = "Produto por UF") + 
   theme(axis.text.x = element_text(angle = 90, 
                                    hjust = 1,
                                    vjust = 0.5),
         plot.title = element_text(hjust = 0.5),
         plot.subtitle = element_text(hjust = 0.5, 
                                      size = 10)) + 
   scale_fill_gradient(low = "white", high = "darkred") 

ggsave(paste(graph_file, extensao_file, sep = "."), path = "./Images")
```

```{r Heatmat entre município e produtos da UF escolhida, echo = TRUE}
filter_uf = "RJ"
filter_produto = c("GASOLINA","DIESEL","DIESEL S10")
graph_file <- paste("Heatmat do Valor de Venda dos combustíveis no Estado",filter_uf, sep = " ")
extensao_file <- "jpg"

sample_combustiveis_agg %>% 
   dplyr::filter(Produto %in% filter_produto, UF == filter_uf) %>%
   ggplot(aes(x = Municipio, 
              y = Produto, 
              fill = Valor_de_Venda)) + 
   geom_tile() + 
   labs(x = "Municípios", 
        y = "Produto", 
        title = graph_file, 
        subtitle = "Produto por Município") + 
   theme(axis.text.x = element_text(angle = 90, 
                                    hjust = 1,
                                    vjust = 0.5),
         plot.title = element_text(hjust = 0.5),
         plot.subtitle = element_text(hjust = 0.5, 
                                      size = 10)) + 
   scale_fill_gradient(low = "white", high = "darkred") 

ggsave(paste(graph_file, extensao_file, sep = "."), path = "./Images")
```

***

# Análise descritiva e de histogramas das variáveis contínuas{#analisedescritivaehistograma}

A próximas etapas da análise foi elaborada considerando a possibilidade de análise a partir da variável produto em relação ao indivíduo UF.

Em relação a binarização, é possível considerar regras de binarização levando em consideração regras disponíveis na literatura, como a regra de Freedman-Diaconis, bem como a regra de Sturge. Para esta análise será utilziada a regra de Freedman-Diaconis.

Como amostra para a respectiva análise, considerou-se o estado do RJ para o produto gasolina. Vale ressaltar que tal análise poderá ser feita para qualquer estado e produto constante na pesquisa realizada pela ANP.

Para as próximas análises, recomanda-se definir os parâmetros das variáveis seguintes.

```{r Variável para análise, echo=TRUE}
filter_uf = "RJ"
filter_produto = "GASOLINA"
```

## Análise descritiva das variáveis contínuas{#analisedescritivavarcontinua}

Para a variável Valor_de_Venda, podemos analisar a centralidade dos dados, dipersão, assimetria, bem como suas estatísticas de ordem, a fim de checar se há presença de outliers.

Para realizar essa análise, utilizar-se-á a função descr do pacote summarytools, e posteriormente realizar a leitura desses dados.

Analise descritiva da variável Valor de Venda por Produto no Brasil.

```{r Analise descritiva da variável Valor de Venda por Produto no Brasil, echo=TRUE}
sample_combustiveis_agg %>% 
   dplyr::filter(Produto == filter_produto) %>%
   dplyr::select(Valor_de_Venda) %>% 
   summarytools::descr()
```
É possível ver pelo critério de skewness, que o valor está entre 0 e 0.5 para assimetria, nos permitindo interpretar que esta distribução possui assimetria leve, com cauda à direita.

Em decorrência desta assimetria, observamos que média e mediana apresentam valores distintos, com a média tendo valor levemente superior, o que aponta que os valores mais distantes do centro da distribuição puxam o valor da média pra cima.

Já a mediana por ser uma estatística de ordem, não é sensível a dados que apresentam alto valor na distribuição, o que é reforçado por seu valor levemente mais baixo que a média.

Se houve-se outliers nesta distribuição a média se descolaria ainda mais da mediana, pois estaria totalmente suscetível à contaminação.

```{r Analise descritiva da variável Valor de Venda por Produto no RJ, echo=TRUE}
sample_combustiveis_agg %>% 
   dplyr::filter(Produto == filter_produto, UF == filter_uf) %>%
   dplyr::select(Valor_de_Venda) %>% 
   summarytools::descr()
```
É possível ver pelo critério de skewness, que o valor está entre 0.5 e 1 para assimetria, nos permitindo interpretar que esta distribução possui assimetria moderada, com cauda à direita.

É possível observar a diferença entre o Brasil e o RJ, considerando que possívelmente o RJ possui mais outliers representativos.

Em decorrência desta assimetria, observamos que média e mediana apresentam valores distintos, com a média tendo valor levemente superior, o que aponta que os valores mais distantes do centro da distribuição puxam o valor da média pra cima.

Já a mediana por ser uma estatística de ordem, não é sensível a dados que apresentam alto valor na distribuição, o que é reforçado por seu valor levemente mais baixo que a média.

## Histogramas das variáveis contínuas{#histogramadasvarcontinuas}

Histograma da variável Valor de Venda por Produto no Brasil.

```{r Histograma do valor do produto vendido nos locais pesquisados no Brasil,echo=TRUE}
graph_file <- paste("Histograma da distribuição do Valor de Venda no Brasil do produto", filter_produto, sep = " ")
extensao_file <- "jpg"

sample_combustiveis_agg %>%
   dplyr::filter(Produto == filter_produto) %>% 
   dplyr::select(Valor_de_Venda) %>% 
   ggplot(aes(x=Valor_de_Venda)) + 
   geom_histogram(aes(y = after_stat(density)) , binwidth=fd, fill = 'lightblue') + 
   xlab('Valor de Venda') + 
   ylab('Densidade de Frequência') + 
   labs(title = graph_file, 
        subtitle = "Binarização pela Regra de FD") + 
   geom_vline(xintercept=c(median(sample_combustiveis_agg$Valor_de_Venda), 
                           mean(sample_combustiveis_agg$Valor_de_Venda))) + 
   annotate("text", x=median(sample_combustiveis_agg$Valor_de_Venda) + 
               -0.2, y=0.1, label="Mediana", angle=90) + 
   annotate("text", x=mean(sample_combustiveis_agg$Valor_de_Venda) + 
               0.2, y=0.1, label="Média", angle=90) + 
   geom_density(linetype = 2) + 
   theme_classic()

ggsave(paste(graph_file, extensao_file, sep = "."), path = "./Images")
```

Histograma da variável Valor de Venda por Produto na UF selecionada.

```{r Histograma do valor do produto vendido nos locais pesquisados na UF selecionada,echo=TRUE}
graph_file <- paste("Histograma da distribuição do Valor de Venda do produto",filter_uf,"do produto",filter_produto, sep = " ")
extensao_file <- "jpg"

sample_combustiveis_agg %>%
   dplyr::filter(Produto == filter_produto, UF == filter_uf) %>% 
   dplyr::select(Valor_de_Venda) %>% 
   ggplot(aes(x=Valor_de_Venda)) + 
   geom_histogram(aes(y = after_stat(density)) , binwidth=fd, fill = 'lightblue') + 
   xlab('Valor de Venda') + 
   ylab('Densidade de Frequência') + 
   labs(title = graph_file, 
        subtitle = "Binarização pela Regra de FD") + 
   geom_vline(xintercept=c(median(sample_combustiveis_agg$Valor_de_Venda), 
                           mean(sample_combustiveis_agg$Valor_de_Venda))) + 
   annotate("text", x=median(sample_combustiveis_agg$Valor_de_Venda) + 
               -0.2, y=0.1, label="Mediana", angle=90) + 
   annotate("text", x=mean(sample_combustiveis_agg$Valor_de_Venda) + 
               0.2, y=0.1, label="Média", angle=90) + 
   geom_density(linetype = 2) + 
   theme_classic()

ggsave(paste(graph_file, extensao_file, sep = "."), path = "./Images")
```

Um conceito para esta etapa da análise é fundamental compreendermos. 

**O que é uma distribuição normal?** 
   
   Podemos conceituar como sendo uma distribuição estatística no formato de um sino e simétrica em relação a média.

**O que simboliza o formato de um sino?**
   
   A maioria dos dados estão concentrados no centro, diminuindo a quantidade destes dados em ambas as direções.

**O que é a simetria em relação a média?**
   
   O termo simetria em relação a média é nada mais do que os valores da mediana e moda concidirem com o valor da média. 

Portanto, pode-se dizer que para que haja simetria e o formato de sino, é necessário que a média, mediana e moda possuam o mesmo valor e o quantitativo de valores do lado esquerdo e direito da média são iguais.

```{r, Filtrando os dados e descrevendo a base}
sample_combustiveis_agg_periodo <- sample_combustiveis_agg %>% 
   dplyr::select(UF, Produto, Data, Valor_de_Venda, Cambio, Brent_USD_Barril, Brent_Real_Barril, PPI) %>% 
   dplyr::group_by(UF, Produto, Data) %>%
   dplyr::summarise(
      Valor_de_Venda = mean(Valor_de_Venda), 
      Cambio = mean(Cambio),
      Brent_USD_Barril = mean(Brent_USD_Barril),
      Brent_Real_Barril = mean(Brent_Real_Barril),
      PPI = mean(PPI),
      .groups = 'drop') %>%
   dplyr::filter(Data %in% c(as.IDate("01-03-2020",
                                      format = "%d-%m-%Y"), 
                             as.IDate("01-03-2021",
                                      format = "%d-%m-%Y"), 
                             as.IDate("01-03-2022",
                                      format = "%d-%m-%Y"),
                             as.IDate("01-03-2023",
                                      format = "%d-%m-%Y"),
                             as.IDate("01-03-2024",
                                      format = "%d-%m-%Y"))
                )
```

Calculando os histogramas para o mesmo evento em diferentes instantes de tempo.

```{r Calculando os histogramas para o mesmo evento em diferentes instantes de tempo, echo=TRUE}
graph_file <- paste("Histrograma da evolução temporal no Brasil do produto", filter_produto, sep = " ")
extensao_file <- "jpg"

sample_combustiveis_agg_periodo %>% 
   dplyr::filter(Produto == filter_produto) %>%
   ggplot(aes(x = Valor_de_Venda)) + 
   geom_histogram(aes(y = after_stat(density)), 
                  binwidth=fd, 
                  fill = 'lightblue') + 
   geom_density(kernel = 'epanechnikov') +
   labs(title = graph_file,
        subtitle = "Binarização pela Regra de FD") +
   facet_wrap(~Data)

ggsave(paste(graph_file, extensao_file, sep = "."), path = "./Images")
```
Neste histograma, considerando o custo de venda da gasolina para todo o Brasil em 03/2020 o custo da gasolina era mais barato, sofrente um aumento significativo 03/2022. É possível observar uma evolução de tendência de aumento entre 2020 e 2022. Em 03/2023 o valor de venda valta ao patamar aproximado de 03/2021. É possível observar uma tendência de curva gaussiana (distribuição normal) em alguns anos.

Analise temporal do combustivel vs Cambio vs Brent vc PPI.

```{r Analise temporal do combustivel vs Cambio vs Brent vc PPI}
graph_file <- paste("Evolução temporal no Brasil do produto", filter_produto, sep = " ")
extensao_file <- "jpg"

sample_combustiveis_agg %>%
   dplyr::filter(Produto == filter_produto) %>%
   dplyr::select(Data, Valor_de_Venda, Cambio, Brent_USD_Barril, Brent_Real_Barril, PPI) %>% 
   dplyr::group_by(Data) %>% 
   dplyr::summarise(
      Valor_de_Venda = mean(Valor_de_Venda),
      Cambio = mean(Cambio),
      Brent_USD_Barril = mean(Brent_USD_Barril),
      Brent_Real_Barril = mean(Brent_Real_Barril),
      PPI = mean(PPI)
   ) %>% 
   
   ggplot(aes(x = Data)) + 
   geom_line(aes(y = Valor_de_Venda, color = "Valor_de_Venda")) + 
   
   geom_point(data = sample_combustiveis_agg_periodo %>%
                 dplyr::filter(Produto == filter_produto) %>%
                 dplyr::group_by(Data) %>% 
                 dplyr::summarise(
                    Valor_de_Venda = mean(Valor_de_Venda), 
                    Cambio = mean(Cambio),
                    Brent_USD_Barril = mean(Brent_USD_Barril),
                    Brent_Real_Barril = mean(Brent_Real_Barril),
                    PPI = mean(PPI),
                    .groups = 'drop'), 
              aes(y = Valor_de_Venda, color = "Valor_de_Venda")) +
   
   geom_line(aes(y = Brent_USD_Barril / 10, color = "Brent USD Barril / 10")) + 
   
   geom_point(data = sample_combustiveis_agg_periodo %>%
                 dplyr::filter(Produto == filter_produto) %>%
                 dplyr::group_by(Data) %>% 
                 dplyr::summarise(
                    Valor_de_Venda = mean(Valor_de_Venda), 
                    Cambio = mean(Cambio),
                    Brent_USD_Barril = mean(Brent_USD_Barril),
                    Brent_Real_Barril = mean(Brent_Real_Barril),
                    PPI = mean(PPI),
                    .groups = 'drop'), 
              aes(y = Brent_USD_Barril / 10, color = "Brent USD Barril / 10")) +
   
   geom_line(aes(y = Brent_Real_Barril / 50, color = "Brent R$ Barril / 50")) +
   
   geom_point(data = sample_combustiveis_agg_periodo %>%
                 dplyr::filter(Produto == filter_produto) %>%
                 dplyr::group_by(Data) %>% 
                 dplyr::summarise(
                    Valor_de_Venda = mean(Valor_de_Venda), 
                    Cambio = mean(Cambio),
                    Brent_USD_Barril = mean(Brent_USD_Barril),
                    Brent_Real_Barril = mean(Brent_Real_Barril),
                    PPI = mean(PPI),
                    .groups = 'drop'), 
              aes(y = Brent_Real_Barril / 50, color = "Brent R$ Barril / 50")) +
   
   geom_line(aes(y = PPI, color = "PPI")) + 
   
   geom_point(data = sample_combustiveis_agg_periodo %>%
                 dplyr::filter(Produto == filter_produto) %>%
                 dplyr::group_by(Data) %>% 
                 dplyr::summarise(
                    Valor_de_Venda = mean(Valor_de_Venda), 
                    Cambio = mean(Cambio),
                    Brent_USD_Barril = mean(Brent_USD_Barril),
                    Brent_Real_Barril = mean(Brent_Real_Barril),
                    PPI = mean(PPI),
                    .groups = 'drop'), 
              aes(y = PPI, color = "PPI")) +
   
   geom_line(aes(y = Cambio, color = "Cambio")) + 
   
   geom_point(data = sample_combustiveis_agg_periodo %>%
                 dplyr::filter(Produto == filter_produto) %>%
                 dplyr::group_by(Data) %>% 
                 dplyr::summarise(
                    Valor_de_Venda = mean(Valor_de_Venda), 
                    Cambio = mean(Cambio),
                    Brent_USD_Barril = mean(Brent_USD_Barril),
                    Brent_Real_Barril = mean(Brent_Real_Barril),
                    PPI = mean(PPI),
                    .groups = 'drop'), 
              aes(y = Cambio, color = "Cambio")) +  
   
   ylab("# Valor de Venda (R$) vs (Cambio, PPI, Brent)") + 
   xlab("Horizonte Temporal") + 
   labs(title = graph_file) + 
   theme_bw()

ggsave(paste(graph_file, extensao_file, sep = "."), path = "./Images")
```

Analise temporal do combustivel vs Cambio vs Brent vc PPI por um determinado UF.

```{r Analise temporal do combustivel vs Cambio vs Brent vc PPI por um determinado UF, echo=TRUE}
graph_file <- paste("Evolução temporal no Estado do",filter_uf, "do produto",filter_produto, sep = " ")
extensao_file <- "jpg"

sample_combustiveis_agg %>%
   dplyr::filter(Produto == filter_produto & UF == filter_uf) %>%
   dplyr::select(UF, Data, Valor_de_Venda, Cambio, Brent_USD_Barril, Brent_Real_Barril, PPI) %>% 
   dplyr::group_by(Data) %>% 
   dplyr::summarise(
      Valor_de_Venda = mean(Valor_de_Venda),
      Cambio = mean(Cambio),
      Brent_USD_Barril = mean(Brent_USD_Barril),
      Brent_Real_Barril = mean(Brent_Real_Barril),
      PPI = mean(PPI)
   ) %>%
   
   ggplot(aes(x = Data)) + 
   geom_line(aes(y = Valor_de_Venda, color = "Valor_de_Venda")) + 
   
   geom_point(data = sample_combustiveis_agg_periodo %>%
                 dplyr::filter(UF == filter_uf, Produto == filter_produto),
                 aes(y = Valor_de_Venda, color = "Valor_de_Venda")) +
   
   geom_line(aes(y = Brent_USD_Barril / 10, color = "Brent USD Barril / 10")) + 
   
   geom_point(data = sample_combustiveis_agg_periodo %>%
                 dplyr::filter(UF == filter_uf, Produto == filter_produto),
              aes(y = Brent_USD_Barril / 10, color = "Brent USD Barril / 10")) +
   
   geom_line(aes(y = Brent_Real_Barril / 50, color = "Brent R$ Barril / 50")) +
   
   geom_point(data = sample_combustiveis_agg_periodo %>%
                 dplyr::filter(UF == filter_uf, Produto == filter_produto),
              aes(y = Brent_Real_Barril / 50, color = "Brent R$ Barril / 50")) +
   
   geom_line(aes(y = PPI, color = "PPI")) + 
   
   geom_point(data = sample_combustiveis_agg_periodo %>%
                 dplyr::filter(UF == filter_uf, Produto == filter_produto),
              aes(y = PPI, color = "PPI")) +
   
   geom_line(aes(y = Cambio, color = "Cambio")) + 
   
   geom_point(data = sample_combustiveis_agg_periodo %>%
                 dplyr::filter(UF == filter_uf, Produto == filter_produto),
              aes(y = Cambio, color = "Cambio")) +
   
   ylab("# Valor de Venda R$ vs (Cambio, PPI, Brent)") + 
   xlab("Horizonte Temporal") + 
   labs(title = graph_file) + 
   theme_bw()

ggsave(paste(graph_file, extensao_file, sep = "."), path = "./Images")
```

A partir dos gráficos acima é possível observar alguma relação entre as variáveis Valor de Venda com o Brent e PPI. Esta relação não é significativa em relação a variável Câmbio.

```{r Calculando corrplot pearson, echo=TRUE}
graph_file <- paste("Pearson - Produto",filter_produto, sep = " ")
extensao_file <- "jpg"

sample_combustiveis_agg %>% 
   dplyr::filter(Produto == filter_produto) %>% 
   dplyr::select(Valor_de_Venda, Valor_de_Compra, Cambio, Brent_Real_Barril, PPI) %>% 
   cor(., method = "pearson") %>% 
   corrplot(., title = graph_file)

ggsave(paste(graph_file, extensao_file, sep = "."), path = "./Images")
```


```{r Calculando corrplot spearman, echo=TRUE}
graph_file <- paste("Spearman - Produto",filter_produto, sep = " ")
extensao_file <- "jpg"

sample_combustiveis_agg %>% 
   dplyr::filter(Produto == filter_produto) %>% 
   dplyr::select(Valor_de_Venda, Valor_de_Compra, Cambio, Brent_Real_Barril, PPI) %>% 
   cor(., method = "spearman") %>% 
   corrplot(., title = graph_file)

ggsave(paste(graph_file, extensao_file, sep = "."), path = "./Images")
```

A partir do corrplot é possível ratificar a relação entre as variáveis Valor de Venda com o Brent e PPI. Esta relação não tão evidente com a variável Câmbio.

É possível observar que as variáveis PPI brent são altamente relacionadas.

***

# Realizando o teste de Hipíotese{#testedehipotese}

Considerando os resultados apresentados anteriormente pelos histogramas, o próximo passo visa realizar o teste da hipótese apresentada no início desta análise.

## Hipótese{#hipotese}

Há evidência estatística na queda do valor de venda dos combustíveis após o término do período de adoção da política de preço da Petrobras?

## Teste de Shapiro Wilk{#testeShapiroWilk}

Será realizado o teste para checar normalidade nas amostras durante e após a adoção da política de preço da Petrobras.

### Após Política de Preço{#apospoliticapreco}

A hipótese nula aqui é: A distribuição do valor de venda por UF segue distribuição normal no mês selecionado para representar após política.

A hipótese alternativa: A distribuição do valor de venda por UF não segue distribuição normal no mês selecionado para representar após política.

#### Aplicando o teste de Shapiro Wilk{#testeShapiroapos}

```{r Shapiro wilk apos politica, echo = TRUE}
apos.politica <- sample_combustiveis_agg_periodo %>% 
   dplyr::filter(Data %in% as.IDate("01-03-2024",format = "%d-%m-%Y")) %>%
   dplyr::select(Valor_de_Venda) 

shapiro.test(apos.politica$Valor_de_Venda)
```
#### Aplicando o QQ-Plot{#qqplotapos}

```{r Qqplot apos politica, echo = TRUE}
qqnorm(apos.politica$Valor_de_Venda)
```

### Durante a Política de Preço{#durantepoliticapreco}

A política de preço adotado pela Petrobra foi até 16/05/2023.

A hipótese nula aqui é: A distribuição do valor de venda por UF segue distribuição normal no mês selecionado para representar durante a política.

A hipótese alternativa: A distribuição do valor de venda por UF não segue distribuição normal no mês selecionado para representar durante a política.

#### Primeiro ano da análise - 01/03/2020{#primeiroanoanalise}

##### Aplicando o teste de Shapiro Wilk{#testeShapiroDurante1}

```{r Shapiro wilk durante politica (ano um da pesquisa), echo = FALSE}
durante.politica <- sample_combustiveis_agg_periodo %>% 
   dplyr::filter(Data %in% as.IDate("01-03-2020",format = "%d-%m-%Y")) %>%
   dplyr::select(Valor_de_Venda)

shapiro.test(durante.politica$Valor_de_Venda)
```

##### Aplicando o QQ-Plot{#qqplotdurante1}

```{r Qqplot durante durante politica (ano um da pesquisa), echo = FALSE}
qqnorm(durante.politica$Valor_de_Venda)
```

##### Teste de Wilcoxon para checar o pareamento{#wilcoxonparemaneto1}

Após política vs. Primeiro ano da Pesquisa durante a política - 01/03/2020).

Realizado o teste de Wilcoxon para checar o pareamento entre as distribuições do valor de venda após e durante a política de preço da Petrobras.

A hipótese nula aqui é: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é igual a zero.

A hipótese alternativa: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante não é igual a zero.

```{r Teste pareamento de wilcox após e durante a politica de preco (ano 1 da pesquisa), echo = FALSE}
wilcox.test(apos.politica$Valor_de_Venda, durante.politica$Valor_de_Venda, paired = T, exact = F)
```

##### Teste de Wilcoxon para checar o pareamento (Maior que){#wilcoxonmaiorque1}

Após política vs. Primeiro ano da Pesquisa durante a política - 01/03/2020).

A hipótese nula aqui é: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é igual a zero.

A hipótese alternativa: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é maior do que zero.

```{r Teste pareamento maior que de wilcox após e durante a politica de preco (ano 1 da pesquisa), echo = FALSE}
wilcox.test(apos.politica$Valor_de_Venda, durante.politica$Valor_de_Venda, paired = T, exact = F, alternative = "greater")
```
##### Teste de Wilcoxon para checar o pareamento (Menor que){#wilcoxonmenorque1}

Após política vs. Primeiro ano da Pesquisa durante a política - 01/03/2020).

A hipótese nula aqui é: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é igual a zero.

A hipótese alternativa: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é menor do que zero.

```{r Teste pareamento menor que de wilcox após e durante a politica de preco (ano 1 da pesquisa), echo = FALSE}
wilcox.test(apos.politica$Valor_de_Venda, durante.politica$Valor_de_Venda, paired = T, exact = F, alternative = "less")
```

#### Segundo ano da análise - 01/03/2021

##### Aplicando o teste de Shapiro Wilk{#testeShapiroDurante2}

```{r Shapiro wilk durante politica (ano dois da pesquisa), echo = FALSE}
durante.politica <- sample_combustiveis_agg_periodo %>% 
   dplyr::filter(Data %in% as.IDate("01-03-2021",format = "%d-%m-%Y")) %>%
   dplyr::select(Valor_de_Venda)

shapiro.test(durante.politica$Valor_de_Venda)
```

##### Aplicando o QQ-Plot{#qqplotdurante2}

```{r Qqplot durante durante politica (ano dois da pesquisa), echo = FALSE}
qqnorm(durante.politica$Valor_de_Venda)
```

##### Teste de Wilcoxon para checar o pareamento{#wilcoxonparemaneto2}

Após política vs. Segundo ano da Pesquisa durante a política - 01/03/2021).

Realizado o teste de Wilcoxon para checar o pareamento entre as distribuições do valor de venda após e durante a política de preço da Petrobras.

A hipótese nula aqui é: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é igual a zero.

A hipótese alternativa: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante não é igual a zero.

```{r Teste pareamento de wilcox após e durante a politica de preco (ano 2 da pesquisa), echo = FALSE}
wilcox.test(apos.politica$Valor_de_Venda, durante.politica$Valor_de_Venda, paired = T, exact = F)
```

##### Teste de Wilcoxon para checar o pareamento (Maior que){#wilcoxonmaiorque2}

Após política vs. Segundo ano da Pesquisa durante a política - 01/03/2021).

A hipótese nula aqui é: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é igual a zero.

A hipótese alternativa: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é maior do que zero.

```{r Teste pareamento maior que de wilcox após e durante a politica de preco (ano 2 da pesquisa), echo = FALSE}
wilcox.test(apos.politica$Valor_de_Venda, durante.politica$Valor_de_Venda, paired = T, exact = F, alternative = "greater")
```

##### Teste de Wilcoxon para checar o pareamento (Menor que){#wilcoxonmenorque2}

Após política vs. Segundo ano da Pesquisa durante a política - 01/03/2021).

A hipótese nula aqui é: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é igual a zero.

A hipótese alternativa: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é menor do que zero.

```{r Teste pareamento menor que de wilcox após e durante a politica de preco (ano 2 da pesquisa), echo = FALSE}
wilcox.test(apos.politica$Valor_de_Venda, durante.politica$Valor_de_Venda, paired = T, exact = F, alternative = "less")
```

#### Terceiro ano da análise - 01/03/2022

##### Aplicando o teste de Shapiro Wilk{#testeShapiroDurante3}

```{r Shapiro wilk durante politica (ano três da pesquisa), echo = FALSE}
durante.politica <- sample_combustiveis_agg_periodo %>% 
   dplyr::filter(Data %in% as.IDate("01-03-2022",format = "%d-%m-%Y")) %>%
   dplyr::select(Valor_de_Venda)

shapiro.test(durante.politica$Valor_de_Venda)
```

##### Aplicando o QQ-Plot{#qqplotdurante3}

```{r Qqplot durante durante politica (ano três da pesquisa), echo = FALSE}
qqnorm(durante.politica$Valor_de_Venda)
```

##### Teste de Wilcoxon para checar o pareamento{#wilcoxonparemaneto3}

Após política vs. Terceiro ano da Pesquisa durante a política - 01/03/2022).

Realizado o teste de Wilcoxon para checar o pareamento entre as distribuições do valor de venda após e durante a política de preço da Petrobras.

A hipótese nula aqui é: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é igual a zero.

A hipótese alternativa: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante não é igual a zero.

```{r Teste pareamento de wilcox após e durante a politica de preco (ano 3 da pesquisa), echo = FALSE}
wilcox.test(apos.politica$Valor_de_Venda, durante.politica$Valor_de_Venda, paired = T, exact = F)
```

##### Teste de Wilcoxon para checar o pareamento (Maior que){#wilcoxonmaiorque3}

Após política vs. Terceiro ano da Pesquisa durante a política - 01/03/2022).

A hipótese nula aqui é: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é igual a zero.

A hipótese alternativa: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é maior do que zero.

```{r Teste pareamento maior que de wilcox após e durante a politica de preco (ano três da pesquisa), echo = FALSE}
wilcox.test(apos.politica$Valor_de_Venda, durante.politica$Valor_de_Venda, paired = T, exact = F, alternative = "greater")
```

##### Teste de Wilcoxon para checar o pareamento (Menor que){#wilcoxonmenorque3}

Após política vs. Terceiro ano da Pesquisa durante a política - 01/03/2022).

A hipótese nula aqui é: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é igual a zero.

A hipótese alternativa: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é menor do que zero.

```{r Teste pareamento menor que de wilcox após e durante a politica de preco (ano três da pesquisa), echo = FALSE}
wilcox.test(apos.politica$Valor_de_Venda, durante.politica$Valor_de_Venda, paired = T, exact = F, alternative = "less")
```

#### Quarto ano da análise - 01/03/2023

##### Aplicando o teste de Shapiro Wilk{#testeShapiroDurante4}

```{r Shapiro wilk durante politica (ano quarto da pesquisa), echo = FALSE}
durante.politica <- sample_combustiveis_agg_periodo %>% 
   dplyr::filter(Data %in% as.IDate("01-03-2023",format = "%d-%m-%Y")) %>%
   dplyr::select(Valor_de_Venda)

shapiro.test(durante.politica$Valor_de_Venda)
```

##### Aplicando o QQ-Plot{#qqplotdurante4}

```{r Qqplot durante durante politica (ano quarto da pesquisa), echo = FALSE}
qqnorm(durante.politica$Valor_de_Venda)
```

##### Teste de Wilcoxon para checar o pareamento{#wilcoxonparemaneto4}

Após política vs. Quarto ano da Pesquisa durante a política - 01/03/2023).

Realizado o teste de Wilcoxon para checar o pareamento entre as distribuições do valor de venda após e durante a política de preço da Petrobras.

A hipótese nula aqui é: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é igual a zero.

A hipótese alternativa: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante não é igual a zero.

```{r Teste pareamento de wilcox após e durante a politica de preco (ano 4 da pesquisa), echo = FALSE}
wilcox.test(apos.politica$Valor_de_Venda, durante.politica$Valor_de_Venda, paired = T, exact = F)
```

##### Teste de Wilcoxon para checar o pareamento (Maior que){#wilcoxonmaiorque4}

Após política vs. Quarto ano da Pesquisa durante a política - 01/03/2023).

A hipótese nula aqui é: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é igual a zero.

A hipótese alternativa: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é maior do que zero.

```{r Teste pareamento maior que de wilcox após e durante a politica de preco (ano quarto da pesquisa), echo = FALSE}
wilcox.test(apos.politica$Valor_de_Venda, durante.politica$Valor_de_Venda, paired = T, exact = F, alternative = "greater")
```

##### Teste de Wilcoxon para checar o pareamento (Menor que){#wilcoxonmenorque4}

Após política vs. Quarto ano da Pesquisa durante a política - 01/03/2023).

A hipótese nula aqui é: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é igual a zero.

A hipótese alternativa: A mediana das diferenças (após - durante) entre as distribuições do valor de venda após e durante é menor do que zero.

```{r Teste pareamento menor que de wilcox após e durante a politica de preco (ano quarto da pesquisa), echo = FALSE}
wilcox.test(apos.politica$Valor_de_Venda, durante.politica$Valor_de_Venda, paired = T, exact = F, alternative = "less")
```

# Manipulando base de dados com dados faltantes e outliers{#manipulandomissingeout}

**O que é completude de dados?**

Completude de dados se refere a ausência de dados em um conjunto de dados. Quando os dados estão completos em um conjunto de dados e sua consistência pode ser validada, dizemos que há qualidade dos dados a serem utilizados em uma análise, possibilitando assim *insights* confiáveis.

**Qual o impacto que os dados faltantes podem ter em uma análise?**

A ausência de dados ou lacunas no conjunto de dados em uma análise, além de proporcionar uma baixa qualidade dos dados, poderá impossibilitar a obtenção de *insights* confiáveis e precisos. A inconfiabilidade nos dados podem gerar interpretações equivocadas e propor decisões errôneas.

## Índice de completude{#indicedecompletude}

```{r Descrevendo os dados faltantes pelo indice de completude,echo=TRUE}
sample_combustiveis_agg %>% dlookr::diagnose()

sample_combustiveis_agg %>% naniar::miss_var_summary()

sample_combustiveis_agg %>% gg_miss_var()

#sample_combustiveis_agg %>% gg_miss_upset()

```

A única variável de interesse que possui missing é a Valor de Compra, intitulada Valor_de_Compra.

## Base de Dados Combustíveis - Visão de missing nacional{#basecobustiveismissingnacional}

Para uma melhor compreensão dos missing existentes nesta variável, algumas investigações foram feitas.

A primeira análise visa visualizar o missing da variável por Regiao.

```{r Quantidade de missing da variável Valor de Compra por Região, echo=TRUE}
df <- sample_combustiveis_agg %>%
  dplyr::group_by(Regiao) %>%
  dplyr::mutate(n_linhas = 1) %>%
  dplyr::summarise(n_missing = sum(is.na(Valor_de_Compra))) %>%
  dplyr::arrange(desc(n_missing))

#knitr::kable(df, format="latex")
knitr::kable(df, 
             format="latex",
             caption = "Quantidade de missing da variável Valor de Compra por Região.",
             align = "c",
             booktabs = TRUE,
             longtable = TRUE,
             linesep = ""
)
```

É possível observar que a região sudeste possui maior quantidade de missing. O gráfico abaixo demonstra esta análise visualmente.

```{r Gráfico da quantidade de missing da variável Valor de Compra por Região, echo=TRUE}
ggplot(df, aes(x = reorder(Regiao, 
                           n_missing, decreasing = TRUE), 
               y = n_missing)) + 
   geom_bar(stat = "identity") + 
   labs(x = "Região", 
        y = "Qtd de Missing", 
        subtitle = "Variável Valor de Compra") + 
   scale_y_continuous(labels = scales::comma_format()) + 
   ggtitle("Análise da Quantidade e Missing por Região") +
   theme(plot.title = element_text(hjust = 0.5),
         plot.subtitle = element_text(hjust = 0.5, 
                                      size = 10)) + 
   scale_fill_brewer(palette = "Set1")

rm("df")
```

Foi feita uma segunda análise considerando a porcentagem de missing sobre a observação desta variável para cada região. É possível observar uma uniformização nas porcentagens entre as regiões.

```{r Porcentagem de missing da variável Valor de Compra por Região, echo=TRUE}
df <- sample_combustiveis_agg %>%
  dplyr::group_by(Regiao) %>%
  dplyr::mutate(n_linhas = 1) %>%
  dplyr::summarise(n_missing = sum(is.na(Valor_de_Compra)),
            n_linhas = sum(n_linhas), 
            porcentagem_missing = round(n_missing / n_linhas, 2)) %>%
  dplyr::arrange(desc(porcentagem_missing))

#kable(df, format="latex")
knitr::kable(df, 
             format="latex",
             caption = "Porcentagem de missing da variável Valor de Compra por Região.",
             align = "c",
             booktabs = TRUE,
             longtable = TRUE,
             linesep = "",)
```

O gráfico abaixo demonstra visualmente esta análise.

```{r Gráfico da porcentagem de missing da variável Valor de Compra por Região, echo=TRUE}
ggplot(df, aes(x = reorder(Regiao, porcentagem_missing, decreasing = TRUE), 
               y = porcentagem_missing)) + 
   geom_bar(stat = "identity") + 
   labs(x = "Região", 
        y = "Análise da Porcentagem de Missing", 
        subtitle = "Variável Valor de Compra") + 
   scale_y_continuous(labels = scales::percent_format()) + 
   ggtitle("Porcentagem de Missing por Região") +
   theme(plot.title = element_text(hjust = 0.5),
         plot.subtitle = element_text(hjust = 0.5, 
                                      size = 10)) + 
   geom_text(aes(label = porcentagem_missing), 
             vjust = 1.5)

rm("df")
```

A mesma análise realizada por estado, foi feita por Estado.

```{r Quantidade de missing da variável Valor de Compra por Estado, echo=TRUE}
df <- sample_combustiveis_agg %>%
   dplyr::group_by(UF) %>%
   dplyr::mutate(n_linhas = 1) %>%
   dplyr::summarise(n_missing = sum(is.na(Valor_de_Compra))) %>%
   dplyr::arrange(desc(n_missing))

#kable(df, format="latex")

knitr::kable(df, 
             format="latex",
             caption = "Quantidade de missing da variável Valor de Compra por Estado.",
             align = "c",
             booktabs = TRUE,
             longtable = TRUE,
             linesep = "",)
```

É possível observar que o missing da respectiva variável é expressivo para os postos de combustíveis de SP, MG e RJ. O gráfico abaixo demonstra esta representatividade.

```{r Gráfico da quantidade de missing da variável Valor de Compra por Estado, echo=TRUE}
ggplot(df, aes(x = reorder(UF, n_missing, decreasing = TRUE), y = n_missing)) + 
   geom_bar(stat = "identity") + 
   labs(x = "Estado", y = "Qtd de Missing", subtitle = "Variável Valor de Compra") + 
   scale_y_continuous(labels = scales::comma_format()) + 
   ggtitle("Análise da Quantidade de Missing por Estado") +
   theme(plot.title = element_text(hjust = 0.5),
         plot.subtitle = element_text(hjust = 0.5, size = 10)) + 
   scale_fill_brewer(palette = "Set1")

rm("df")
```

Foi feita uma segunda análise considerando a porcentagem de missing sobre a observação desta variável para cada estado. É possível observar valores próximos.

```{r Porcentagem de missing da variável Valor de Compra por Estado, echo=TRUE}
df <- sample_combustiveis_agg %>%
  dplyr::group_by(UF) %>%
  dplyr::mutate(n_linhas = 1) %>%
  dplyr::summarise(n_missing = sum(is.na(Valor_de_Compra)),
            n_linhas = sum(n_linhas), 
            porcentagem_missing = round(n_missing / n_linhas, 2)) %>%
  dplyr::arrange(desc(porcentagem_missing))

#kable(df, format="latex")
knitr::kable(df, 
             format="latex",
             caption = "Porcentagem de missing da variável Valor de Compra por Estado.",
             align = "c",
             booktabs = TRUE,
             longtable = TRUE,
             linesep = "",)
```

O gráfico abaixo demonstra visualmente estes valores.

```{r Gráfico da porcentagem de missing da variável Valor de Compra por Estado, echo=TRUE}
ggplot(df, aes(x = reorder(UF, 
                           porcentagem_missing, decreasing = TRUE), 
               y = porcentagem_missing)) + 
   geom_bar(stat = "identity") + 
   labs(x = "Estado", 
        y = "Porcentagem de Missing", 
        subtitle = "Variável Valor de Compra") + 
   scale_y_continuous(labels = scales::percent_format()) + 
   ggtitle("Análise da Porcentagem de Missing por Estado") +
   theme(plot.title = element_text(hjust = 0.5),
         plot.subtitle = element_text(hjust = 0.5, size = 10)) + 
   geom_text(aes(label = porcentagem_missing), 
             angle = 90, 
             vjust = 0.5, 
             hjust = 1.5)


rm("df")
```

## Base de Dados Combustíveis - Visão de missing estado RJ{#basecobustiveismissingrj}

A próxima análise visa compreender a quantidade de missing da variável Valor de Compra nos municípios do Estado do RJ.

```{r Quantidade de missing da variável Valor de Compra no Estado do RJ, echo=TRUE}
df <- sample_combustiveis_agg %>% dplyr::filter(UF == "RJ") %>%
  dplyr::group_by(Municipio) %>%
  dplyr::mutate(n_linhas = 1) %>%
  dplyr::summarise(n_missing = sum(is.na(Valor_de_Compra))) %>%
  dplyr::arrange(desc(n_missing))


#kable(df, format="latex")
knitr::kable(df, 
             format="latex",
             caption = "Quantidade de missing da variável Valor no Estado do RJ.",
             align = "c",
             booktabs = TRUE,
             longtable = TRUE,
             linesep = "",)
```

É possível observar os cinco municípios com maior quantidade de missing encontram-se na região metropolitana do Rio de Janeiro.

O gráfico a seguir desmonstra esta analise visualmente.

```{r Gráfico da quantidade de missing da variável Valor de Compra no Estado do RJ, echo=TRUE}
ggplot(df, aes(x = reorder(Municipio, n_missing, decreasing = TRUE), 
               y = n_missing)) + 
   geom_bar(stat = "identity") + 
   labs(x = "Município", 
        y = "Qtd de Missing", 
        subtitle = "Variável Valor de Compra") + 
   scale_y_continuous(labels = scales::comma_format()) + 
   ggtitle("Análise da Quantidade de Missing no Estado do RJ") +
   theme(plot.title = element_text(hjust = 0.5),
         plot.subtitle = element_text(hjust = 0.5, 
                                      size = 10),
         axis.text.x = element_text(angle = 90, 
                                    hjust = 1)
   ) + 
   scale_fill_brewer(palette = "Set1")

rm("df")
```

Foi feita uma segunda análise considerando a porcentagem de missing sobre a observação desta variável para cada Município do Rio de Janeiro.

```{r Porcentagem de missing da variável Valor de Compra por Município do RJ, echo=TRUE}
df <- sample_combustiveis_agg %>% dplyr::filter(UF == "RJ") %>%
  dplyr::group_by(Municipio) %>%
  dplyr::mutate(n_linhas = 1) %>%
  dplyr::summarise(n_missing = sum(is.na(Valor_de_Compra)),
            n_linhas = sum(n_linhas), 
            porcentagem_missing = round(n_missing / n_linhas, 2)) %>%
  dplyr::arrange(desc(porcentagem_missing))

df

#kable(df, format="latex")
knitr::kable(df, 
             format="latex",
             caption = "Porcentagem de missing da variável 
             Valor de Compra por Município RJ.",
             align = "c",
             booktabs = TRUE,
             longtable = TRUE,
             linesep = "",)
```

O gráfico abaixo demonstra visualmente esta análise.

```{r Gráfico da porcentagem de missing da variável Valor de Compra por Município, echo=TRUE}
ggplot(df, aes(x = reorder(Municipio, 
                           porcentagem_missing, 
                           decreasing = TRUE), 
               y = porcentagem_missing)) + 
   geom_bar(stat = "identity") + 
   labs(x = "Município", 
        y = "Porcentagem de Missing", 
        subtitle = "Variável Valor de Compra") + 
   scale_y_continuous(labels = scales::percent_format()) + 
   ggtitle("Análise da Porcentagem de Missing por Município") +
   theme(plot.title = element_text(hjust = 0.5),
         plot.subtitle = element_text(hjust = 0.5, size = 10),
         axis.text.x = element_text(angle = 90, hjust = 1)) +  
   geom_text(aes(label = porcentagem_missing), angle = 90, vjust = 0.5, hjust = 1.5)

rm("df")
```
É possível observar nesta análise que o município de Mesquita que estava em último na análise de quantidade de missing agora é o primeiro. Para compreender melhor, é necessário entender a frequência relativa deste município na pesquisa. O que se pode deduzir neste primeiro momento é que 100% dos postos pesquisados não informaram o valor da variável alvo desta análise. Tal afirmação é observada pela quantidade de valores em n_linhas igual a n_missing, onde n_linhas representa a quatidade de postos pesquisados.

É possível observar que somente Mesquita, dentre os cinco primeiros municípios, faz parte dos municípios da região metropolitana do Rio de Janeiro.

***

## Realizando teste de Little para checar se os dados faltantes são completamente aleatórios{#testelittle}

```{r Teste de little para dados faltantes de valor_de_compra, echo = TRUE}
sample_combustiveis_agg %>% dplyr::select(Valor_de_Compra) %>% naniar::mcar_test()
# O resultado abaixo rejeita a hipótese de que os dados faltantes são completamente aleatórios, pois o P-Valor é zero.
# Portanto, neste cenário, é necessário verificar se os dados faltantes são aleatórios ou não aleatórios.
```

## Realizando a imputação de dados{#imputandodados}

```{r Imputando dados, echo = TRUE}
sample_combustiveis_agg_input <- sample_combustiveis_agg

mice(sample_combustiveis_agg_input, method ="norm.predict", seed = 1, m = 1, print = FALSE)
```